---
name: 'Foundry MCP Usage Guide'
description: 'Comprehensive guide for using Foundry MCP tools effectively in AI-assisted development'
alwaysApply: true
---

# Foundry MCP Usage Guide for AI Assistants

## Overview

Foundry MCP is a project management tool designed specifically for AI coding assistants. It provides structured project context, specification management, and workflow guidance through a standardized directory structure in `~/.foundry/`.

**Key Principles:**

- **Content Agnostic**: Foundry manages structure, not content opinions
- **LLM-Driven**: You provide complete content as arguments
- **User-Controlled**: Users control content, CLI manages structure
- **Workflow-Aware**: Tools provide next-steps guidance for efficient development

## CRITICAL: Understanding Document Purpose

**These documents serve as COMPLETE CONTEXT for future LLMs and developers**:

- Each document must contain ALL information needed for someone with no prior project knowledge
- Future LLMs will load these as PRIMARY reference for implementation work
- Apply "Cold Start Test": Could a skilled developer implement using only this document?
- Documents must be self-contained with comprehensive architectural and business context
- Include implementation prerequisites, dependencies, decision rationale, and edge cases

**Document Creation Mindset**:
- Write for someone who has never seen this project before
- Include WHY decisions were made, not just WHAT was decided
- Provide complete technical and business context for implementation
- Assume the reader needs to understand the full system to implement successfully

## Core Concepts

### Project Structure

Each Foundry project contains:

- **`vision.md`**: High-level product vision and goals (200+ characters, you provide)
- **`tech-stack.md`**: Technology decisions and architecture (150+ characters, you provide)
- **`summary.md`**: Concise context for quick LLM consumption (100+ characters, you provide)
- **`specs/`**: Directory containing timestamped feature specifications

### Specification Structure

Each spec contains:

- **`spec.md`**: Detailed feature requirements, acceptance criteria, implementation approach
- **`task-list.md`**: Implementation checklist with checkboxes (- [ ] task, - [x] completed)
- **`notes.md`**: Additional context, design decisions, and implementation notes

## Tool Usage Guidelines

### When to Use Each Tool

#### Project Management

- **`mcp_foundry_create_project`**: For NEW initiatives requiring full project context

  - When: Starting fresh projects, establishing project foundation
  - You provide: Complete vision, detailed tech-stack, concise summary
  - MCP creates: Project directory structure and validates content

- **`mcp_foundry_analyze_project`**: For EXISTING codebases you want to manage with Foundry

  - When: Adding Foundry management to projects with existing code
  - Process: First explore codebase, then provide analyzed vision/tech-stack/summary
  - Best for: Documentation, structured management of legacy projects

- **`mcp_foundry_load_project`**: ALWAYS do this first when working on existing projects
  - When: Starting work sessions, understanding project scope
  - Returns: Project vision, tech-stack, summary, available specs
  - Critical: Never create specs without loading project context first

#### Specification Management

- **`mcp_foundry_create_spec`**: Breaking down features into detailed implementation plans

  - When: Starting new features or user stories
  - You provide: Feature spec, task breakdown, implementation notes
  - Creates: Timestamped directory (YYYYMMDD_HHMMSS_feature_name)

- **`mcp_foundry_load_spec`**: Reviewing specifications and checking progress

  - When: Continuing work on existing features, checking task status
  - Returns: Complete spec content with project context

- **`mcp_foundry_update_spec`**: Updating spec files with three operation types for different use cases

  - **File Types**: `spec` (spec.md), `tasks` (task-list.md), `notes` (notes.md)
  - **Operations**: `replace`, `append`, or `context_patch` - REQUIRED
  - **Usage**:

    ```
    # Traditional operations - full content
    mcp_foundry_update_spec <project> <spec> --spec "<content>" --operation <replace|append>

    # Context-based patching - targeted updates
    mcp_foundry_update_spec <project> <spec> --operation context_patch --context-patch '{
      "file_type": "tasks",
      "operation": "replace",
      "before_context": ["- [ ] Implement user auth"],
      "after_context": ["- [ ] Add password hashing"],
      "content": "- [x] Implement user auth"
    }'
    ```

  - **Operation Types**:
    - **`--operation replace`**: Completely replaces file content with new content
      - **Use when**: Major changes, complete rewrites, replacing outdated content
      - **Risk**: Existing content is permanently lost
    - **`--operation append`**: Adds new content to the END of existing content only
      - **Use when**: Adding new content to end of files, building up specifications iteratively
      - **IMPORTANT**: Append only adds to the bottom - it cannot edit existing content or insert in the middle
      - **Risk**: Low - existing content is preserved, but cannot modify existing sections
    - **`--operation context_patch`**: Makes precise, targeted updates using surrounding text context
      - **Use when**: Small targeted changes (mark task complete, add single item, fix specific content)
      - **Benefits**: 70-90% token reduction, precise targeting, no line number precision needed
      - **Requirements**: 3-5 lines of surrounding context for reliable matching
      - **JSON Format**: Requires JSON with file_type, operation (insert/replace/delete), before_context, after_context, content
  - **Best Practices**:
    - **ALWAYS load current content first**: Use `mcp_foundry_load_spec` before context patching
    - Use `context_patch` for small targeted changes: Mark tasks complete, add single requirements, fix typos
    - Use `append` for adding content to end: New tasks at bottom, progress updates, accumulating notes
    - Use `replace` for major changes: Complete rewrites, editing existing content, requirement changes
    - **Never use `append` to modify existing content** - it only adds to the end
    - Context patching requires unique surrounding text for reliable matching

#### Discovery & Validation

- **`mcp_foundry_list_projects`**: Discovering available projects

  - When: Finding project names, checking what exists
  - Returns: Project names, creation dates, spec counts

- **`mcp_foundry_validate_content`**: Checking content before creating projects/specs

  - When: Ensuring content meets length/format requirements
  - Use this proactively to avoid validation errors

- **`mcp_foundry_get_foundry_help`**: Getting workflow guidance and examples
  - Topics: `workflows`, `content-examples`, `project-structure`, `parameter-guidance`, `context-patching`
  - Use when: Understanding best practices, troubleshooting, learning context patching
  - **Essential**: Use `context-patching` topic for targeted update guidance and examples

## Content Requirements & Boundaries

### What You MUST Provide

**Always include these in your arguments:**

- **Vision** (200+ chars): Problem statement, target users, value proposition, roadmap priorities
- **Tech Stack** (150+ chars): Languages, frameworks, databases, deployment, rationale
- **Summary** (100+ chars): 2-3 sentences capturing project essence
- **Specifications**: Requirements, acceptance criteria, implementation approach, dependencies
- **Task Lists**: Specific, actionable implementation steps with checkboxes
- **Notes**: Design decisions, context, implementation details

### What CLI Handles

**Never include these in content:**

- File structure and organization
- Content validation (length, format only)
- Directory creation and timestamps
- Project/spec naming conventions
- Error handling and recovery suggestions

### Content Formatting Guidelines

#### Vision (vision.md)

```markdown
## Problem Statement

[Describe the problem being solved]

## Target Users

[Who benefits from this solution]

## Value Proposition

[Unique advantages and competitive edge]

## Key Features & Roadmap

[Main capabilities and development priorities]
```

#### Tech Stack (tech-stack.md)

```markdown
## Backend

- **Language**: [choice] - [rationale]
- **Framework**: [choice] - [why this framework]

## Database

- **Type**: [choice] - [use case fit]

## Deployment

- **Platform**: [choice] - [scaling/scalability needs]
```

#### Specifications (spec.md)

```markdown
# Feature Name

## Overview

[Purpose and scope]

## Requirements

- [Functional requirements]
- [Non-functional requirements]

## Acceptance Criteria

- [ ] Criterion 1
- [ ] Criterion 2

## Implementation Approach

[Technical strategy, architecture decisions]

## Dependencies

[What this feature depends on]
```

#### Task Lists (task-list.md)

```markdown
- [ ] Implement user authentication system
- [ ] Add password hashing and validation
- [ ] Create user registration endpoint
- [ ] Add login/logout functionality
- [ ] Implement session management
```

## Best Practices & Workflow Patterns

### 1. Always Load Context First

```
# ✅ Good: Load project context before working
mcp_foundry_load_project project-name
mcp_foundry_create_spec project-name new-feature

# ❌ Avoid: Creating specs without context
mcp_foundry_create_spec project-name new-feature
```

### 2. Use Iterative Development

```
# Create initial spec
mcp_foundry_create_spec my-project user-auth

# OPTION 1: Context patching for targeted updates (PREFERRED for small changes)
# First, load current content to see context
mcp_foundry_load_spec my-project 20240101_user_auth

# Mark task complete using context patching (70-90% token reduction)
mcp_foundry_update_spec my-project 20240101_user_auth --operation context_patch --context-patch '{
  "file_type": "tasks",
  "operation": "replace",
  "before_context": ["## Phase 1"],
  "after_context": ["- [ ] Add password hashing"],
  "content": "- [x] Implement user authentication"
}'

# Insert new requirement using context patching
mcp_foundry_update_spec my-project 20240101_user_auth --operation context_patch --context-patch '{
  "file_type": "spec",
  "operation": "insert",
  "section_context": "## Requirements",
  "before_context": ["- Password hashing with bcrypt"],
  "after_context": ["- Session management"],
  "content": "- Two-factor authentication support"
}'

# OPTION 2: Traditional append for adding to end of files
# Add new tasks to the bottom of task list (append only adds to end)
mcp_foundry_update_spec my-project 20240101_user_auth --tasks "- [ ] New task added to bottom" --operation append

# Add implementation notes to the bottom (append only adds to end)
mcp_foundry_update_spec my-project 20240101_user_auth --notes "## New Implementation Notes\nAdditional notes added to bottom of file." --operation append
```

### 3. Follow Next Steps Guidance

- Every Foundry command returns `next_steps` and `workflow_hints`
- Follow these suggestions for efficient development
- Use `mcp_foundry_get_foundry_help workflows` for additional guidance

### 4. Validate Content Proactively

```
# Check content before creating
mcp_foundry_validate_content vision --content "Your vision content here"
mcp_foundry_validate_content spec --content "Your spec content here"
```

### 5. Use Appropriate Spec Granularity

- **One spec per feature/story**: Don't create monolithic specs
- **Use task-list.md**: Break features into actionable implementation steps
- **Use notes.md**: Document design decisions and rationale
- **Update regularly**: Use append operations to track progress

## Common Workflows

### New Project Setup

1. **Create Project**: `mcp_foundry_create_project my-app --vision "..." --tech-stack "..." --summary "..."`
2. **Create First Spec**: `mcp_foundry_create_spec my-app user-auth --spec "..." --tasks "..." --notes "..."`
3. **Follow next_steps** for iterative development

### Feature Development Cycle

1. **Load Project**: `mcp_foundry_load_project my-app` (get context)
2. **Create Spec**: `mcp_foundry_create_spec my-app payment-integration`
3. **Update Progress**: Use `mcp_foundry_update_spec` with `append` to add new tasks to bottom
4. **Add Notes**: Document implementation decisions by appending to notes
5. **Load Spec**: Review progress and get workflow guidance

### Existing Codebase Analysis

1. **Explore Codebase**: Use Search, Grep, Read tools to understand structure
2. **Analyze Project**: `mcp_foundry_analyze_project analyzed-app --vision "..." --tech-stack "..." --summary "..."`
3. **Create Specs**: Add feature development plans within analyzed project

### Context Loading for Conversations

1. **Quick Context**: Load project summary for high-level understanding
2. **Detailed Context**: Load specific specs for implementation work
3. **Full Context**: Load entire project when starting comprehensive work

## Error Handling & Troubleshooting

### Content Validation Errors

- **"Content too short"**: Provide more detailed content (vision: 200+, tech-stack: 150+, summary: 100+)
- **"Content validation failed"**: Use `validate-content` to check before creating
- **Solution**: Expand content with more specific details and examples

### Project/Spec Not Found

- **"Project not found"**: Use `list-projects` to see available projects
- **"Spec not found"**: Load project first to see available specs
- **Solution**: Always load project context before working with specs

### File Operation Errors

- **Permission denied**: May need to run with appropriate permissions
- **File locked**: Close files in other applications
- **Solution**: Check file permissions and close conflicting applications

### MCP vs CLI Tool Confusion

- **MCP Tools**: Available through AI assistant interface (all core Foundry functionality)
- **CLI Tools**: Use terminal/command line (delete-spec, install/uninstall/status commands)
- **Most tools work through both interfaces**: create-project, update-spec, load-project, etc.
- **When to use CLI**: For installation management, status checking, deletion operations

## Tips for Effective Usage

1. **Start with Context**: Always load project before creating specs
2. **Use Append for Updates**: Build up task lists and notes incrementally
3. **Follow Guidance**: Pay attention to next_steps and workflow_hints
4. **Validate First**: Use validate-content to avoid rejection
5. **Keep Specs Focused**: One feature per spec, use task-list for breakdown
6. **Document Decisions**: Use notes.md for rationale and context
7. **Update Regularly**: Mark tasks complete, add implementation notes
8. **Get Help**: Use get-foundry-help for workflow guidance

## Quick Reference

### Most Common Commands

```
# Start working on existing project
mcp_foundry_load_project my-project

# Create new feature spec
mcp_foundry_create_spec my-project user-auth

# PREFERRED: Context patching for targeted updates (load content first)
mcp_foundry_load_spec my-project 20240101_user_auth
mcp_foundry_update_spec my-project 20240101_user_auth --operation context_patch --context-patch '{
  "file_type": "tasks",
  "operation": "replace",
  "before_context": ["- [ ] Implement authentication"],
  "after_context": ["- [ ] Add password hashing"],
  "content": "- [x] Implement authentication"
}'

# Traditional: Add new tasks to bottom of task list (append only adds to end)
mcp_foundry_update_spec my-project 20240101_user_auth --tasks "- [ ] New task at bottom" --operation append

# Get help (including context patching guidance)
mcp_foundry_get_foundry_help context-patching
mcp_foundry_get_foundry_help workflows
```

### Content Length Requirements

- **Vision**: 200+ characters (2-4 paragraphs with examples)
- **Tech Stack**: 150+ characters (detailed technology choices with rationale)
- **Summary**: 100+ characters (2-3 sentences capturing essence)
- **Specifications**: Comprehensive but focused on requirements and approach
- **Task Lists**: Specific, actionable implementation steps
- **Notes**: Design decisions, context, implementation details

Remember: Foundry manages structure, you provide content. Focus on comprehensive, well-structured content that helps future development.