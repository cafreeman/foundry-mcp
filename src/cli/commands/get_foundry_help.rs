//! Implementation of the get_foundry_help command

use crate::cli::args::GetFoundryHelpArgs;
use crate::types::responses::{
    FoundryResponse, GetFoundryHelpResponse, HelpContent, ValidationStatus,
};
use anyhow::Result;

pub async fn execute(args: GetFoundryHelpArgs) -> Result<FoundryResponse<GetFoundryHelpResponse>> {
    let topic = args.topic.as_deref().unwrap_or("overview");

    let content = match topic {
        "workflows" => create_workflows_help(),
        "decision-points" => create_decision_points_help(),
        "content-examples" => create_content_examples_help(),
        "project-structure" => create_project_structure_help(),
        "parameter-guidance" => create_parameter_guidance_help(),
        "tool-capabilities" => create_tool_capabilities_help(),
        "context-patching" => create_context_patching_help(),
        _ => create_overview_help(),
    };

    let next_steps = vec![
        "Available help topics: workflows, decision-points, content-examples, project-structure, parameter-guidance, tool-capabilities, context-patching".to_string(),
        "Choose topics based on what you need guidance for".to_string(),
        "Use decision-points topic to understand when each tool is appropriate".to_string(),
        "Use context-patching topic for targeted update guidance and examples".to_string(),
    ];

    let workflow_hints = vec![
        "Help topics provide user-driven decision support, not automated sequences".to_string(),
        "All commands return JSON for programmatic consumption".to_string(),
        "Content must be provided by LLMs as arguments - Foundry manages structure only"
            .to_string(),
        "Always wait for user intent before suggesting tools".to_string(),
    ];

    Ok(FoundryResponse {
        data: GetFoundryHelpResponse {
            topic: topic.to_string(),
            content,
        },
        next_steps,
        validation_status: ValidationStatus::Complete,
        workflow_hints,
    })
}

fn create_overview_help() -> HelpContent {
    HelpContent {
        title: "Foundry - Project Management for AI Coding Assistants".to_string(),
        description: "Foundry is a CLI tool that manages project structure in ~/.foundry/ to help LLMs maintain context about software projects through structured specifications. Foundry is content-agnostic - LLMs provide ALL content as arguments, Foundry manages file structure.".to_string(),
        examples: vec![
            "foundry create_project my-app --vision '...' --tech-stack '...' --summary '...'".to_string(),
            "foundry load_project my-app  # Load complete project context".to_string(),
            "foundry create_spec my-app user_auth --spec '...' --notes '...' --tasks '...'".to_string(),
            "foundry list_projects  # Discover available projects".to_string(),
        ],
        workflow_guide: vec![
            "Tools available based on user intent - no fixed sequences".to_string(),
            "Use 'foundry get_foundry_help decision-points' for guidance on tool selection".to_string(),
            "All content (vision, specs, notes) must be provided by LLMs".to_string(),
            "Foundry creates structured file organization for consistent context".to_string(),
            "Always wait for user to express intent before suggesting next tools".to_string(),
        ],
    }
}

fn create_workflows_help() -> HelpContent {
    HelpContent {
        title: "User-Driven Foundry Usage Patterns".to_string(),
        description: "Guidance for using Foundry tools based on user intent and project context, emphasizing user-driven decisions rather than automated sequences.".to_string(),
        examples: vec![
            "# When user expresses intent to start a new project:".to_string(),
            "→ Ask user to provide vision, tech-stack, and summary content".to_string(),
            "→ Use: foundry create_project PROJECT_NAME --vision '...' --tech-stack '...' --summary '...'".to_string(),
            "→ Wait for user to express what they want to work on next".to_string(),
            "".to_string(),
            "# When user wants to work with existing codebase:".to_string(),
            "→ Use analysis tools (codebase_search, grep_search, read_file) to understand code".to_string(),
            "→ Create project structure based on your analysis findings".to_string(),
            "→ Use: foundry analyze_project PROJECT_NAME --vision '...' --tech-stack '...' --summary '...'".to_string(),
            "".to_string(),
            "# When user mentions a specific feature to implement:".to_string(),
            "→ Ask user to describe feature requirements and approach".to_string(),
            "→ Use: foundry create_spec PROJECT_NAME FEATURE_NAME --spec '...' --notes '...' --tasks '...'".to_string(),
            "→ Let user guide implementation approach".to_string(),
            "".to_string(),
            "# When user wants to continue previous work:".to_string(),
            "→ Use: foundry list_projects to show available options".to_string(),
            "→ Use: foundry load_project PROJECT_NAME to get project context".to_string(),
            "→ Ask user what they want to work on specifically".to_string(),
            "".to_string(),
            "# When user wants to make targeted updates to existing specs:".to_string(),
            "→ Use: foundry load_spec PROJECT_NAME SPEC_NAME to see current content".to_string(),
            "→ For small changes (mark task complete, add single item): use context patching".to_string(),
            "→ For major changes (complete rewrites): use replace operation".to_string(),
            "→ For additions to end of file: use append operation".to_string(),
        ],
        workflow_guide: vec![
            "Always wait for user intent before suggesting tools".to_string(),
            "Provide options and capabilities, not directive sequences".to_string(),
            "Always provide complete content in arguments - never expect Foundry to generate content".to_string(),
            "Use validate_content to check content quality before creating projects/specs".to_string(),
            "Ask clarifying questions when user intent is unclear".to_string(),
            "Let users drive the workflow - tools support user goals".to_string(),
            "For targeted updates, use context patching instead of full file replacement".to_string(),
            "Context patching requires 3-5 lines of surrounding context for reliable matching".to_string(),
            "Always load current content before attempting context patches".to_string(),
        ],
    }
}

fn create_content_examples_help() -> HelpContent {
    HelpContent {
        title: "Content Examples and Markdown Formatting Guidelines".to_string(),
        description: "Comprehensive formatting standards, content templates, and markdown structure guidelines for all foundry content types.".to_string(),
        examples: vec![
            "# MARKDOWN FORMATTING STANDARDS".to_string(),
            "".to_string(),
            "## Header Hierarchy:".to_string(),
            "# Main Document Title (for specs only)".to_string(),
            "## Major Sections (Problem, Requirements, Implementation)".to_string(),
            "### Subsections (API Design, Database Schema, Error Handling)".to_string(),
            "#### Minor Details (specific implementation notes)".to_string(),
            "".to_string(),
            "## Lists and Structure:".to_string(),
            "- Use bullet points for features, requirements, considerations".to_string(),
            "1. Use numbered lists for sequential steps or priorities".to_string(),
            "- [ ] Use checkboxes for task lists (uncompleted)".to_string(),
            "- [x] Use checked boxes for completed tasks".to_string(),
            "".to_string(),
            "## Code and Technical Content:".to_string(),
            "```rust".to_string(),
            "// Use language-specific code blocks".to_string(),
            "fn example() { }".to_string(),
            "```".to_string(),
            "`inline code` for variables, commands, or short snippets".to_string(),
            "".to_string(),
            "## Tables for Complex Information:".to_string(),
            "| API Endpoint | Method | Purpose |".to_string(),
            "| ------------ | ------ | ------- |".to_string(),
            "| /api/users   | GET    | List users |".to_string(),
            "".to_string(),
            "# VISION CONTENT TEMPLATE (200+ chars):".to_string(),
            "".to_string(),
            "## Problem".to_string(),
            "[Specific problem statement with context and impact]".to_string(),
            "".to_string(),
            "## Target Users".to_string(),
            "- Primary: [user type with specific pain points]".to_string(),
            "- Secondary: [additional user segments]".to_string(),
            "".to_string(),
            "## Value Proposition".to_string(),
            "[Unique solution approach and competitive advantages]".to_string(),
            "".to_string(),
            "## Key Features".to_string(),
            "1. [Core feature with user benefit]".to_string(),
            "2. [Secondary feature with business value]".to_string(),
            "3. [Future capability or integration]".to_string(),
            "".to_string(),
            "# TECH STACK TEMPLATE (150+ chars):".to_string(),
            "".to_string(),
            "## Backend".to_string(),
            "- **Language**: Rust 1.70+ (performance, safety)".to_string(),
            "- **Framework**: Tokio async runtime (concurrency)".to_string(),
            "- **Database**: PostgreSQL 14+ (ACID compliance, JSON support)".to_string(),
            "".to_string(),
            "## Frontend".to_string(),
            "- **Framework**: React 18 with TypeScript (type safety)".to_string(),
            "- **State**: Redux Toolkit (predictable state management)".to_string(),
            "".to_string(),
            "## Deployment".to_string(),
            "- **Platform**: AWS ECS (container orchestration)".to_string(),
            "- **CI/CD**: GitHub Actions (automated testing/deployment)".to_string(),
            "".to_string(),
            "## Rationale".to_string(),
            "[Brief explanation of technology choices and constraints]".to_string(),
            "".to_string(),
            "# SPECIFICATION TEMPLATE (200+ chars):".to_string(),
            "".to_string(),
            "# [Feature Name]".to_string(),
            "".to_string(),
            "## Overview".to_string(),
            "[Feature description, purpose, and context within the system]".to_string(),
            "".to_string(),
            "## Requirements".to_string(),
            "".to_string(),
            "### Functional Requirements".to_string(),
            "- FR1: [Specific functional requirement]".to_string(),
            "- FR2: [Another functional requirement]".to_string(),
            "".to_string(),
            "### Non-Functional Requirements".to_string(),
            "- Performance: [specific performance criteria]".to_string(),
            "- Security: [security requirements and constraints]".to_string(),
            "".to_string(),
            "## Acceptance Criteria".to_string(),
            "1. **Given** [context], **When** [action], **Then** [expected result]".to_string(),
            "2. **Given** [context], **When** [action], **Then** [expected result]".to_string(),
            "".to_string(),
            "## Implementation Approach".to_string(),
            "".to_string(),
            "### Architecture".to_string(),
            "[High-level approach and component interaction]".to_string(),
            "".to_string(),
            "### API Design".to_string(),
            "```http".to_string(),
            "POST /api/endpoint".to_string(),
            "Content-Type: application/json".to_string(),
            "".to_string(),
            "{".to_string(),
            "  \"param\": \"value\"".to_string(),
            "}".to_string(),
            "```".to_string(),
            "".to_string(),
            "### Database Changes".to_string(),
            "[Schema modifications, migrations, indexes]".to_string(),
            "".to_string(),
            "## Testing Strategy".to_string(),
            "- Unit tests: [specific test coverage]".to_string(),
            "- Integration tests: [component interaction testing]".to_string(),
            "- E2E tests: [user workflow validation]".to_string(),
            "".to_string(),
            "# NOTES TEMPLATE (50+ chars):".to_string(),
            "".to_string(),
            "## Design Decisions".to_string(),
            "- **Choice**: [decision made]".to_string(),
            "- **Rationale**: [why this approach]".to_string(),
            "- **Alternatives**: [other options considered]".to_string(),
            "".to_string(),
            "## Dependencies".to_string(),
            "- [External system or feature dependency]".to_string(),
            "- [Library or service requirement]".to_string(),
            "".to_string(),
            "## Implementation Notes".to_string(),
            "- [Technical consideration or constraint]".to_string(),
            "- [Performance or security consideration]".to_string(),
            "".to_string(),
            "## Future Enhancements".to_string(),
            "- [Potential improvement or extension]".to_string(),
            "- [Scalability consideration]".to_string(),
            "".to_string(),
            "# TASK LIST TEMPLATE (100+ chars):".to_string(),
            "".to_string(),
            "## Phase 1: Setup and Architecture".to_string(),
            "- [ ] Create database schema and migrations".to_string(),
            "- [ ] Set up API endpoint structure".to_string(),
            "- [ ] Implement core data models".to_string(),
            "- [ ] Write unit tests for models".to_string(),
            "".to_string(),
            "## Phase 2: Core Implementation".to_string(),
            "- [ ] Implement business logic layer".to_string(),
            "- [ ] Add input validation and error handling".to_string(),
            "- [ ] Create API endpoints with proper responses".to_string(),
            "- [ ] Write integration tests for API".to_string(),
            "".to_string(),
            "## Phase 3: Frontend Integration".to_string(),
            "- [ ] Create UI components".to_string(),
            "- [ ] Implement state management".to_string(),
            "- [ ] Add form validation and user feedback".to_string(),
            "- [ ] Write E2E tests for user workflows".to_string(),
            "".to_string(),
            "## Phase 4: Testing and Deployment".to_string(),
            "- [ ] Performance testing and optimization".to_string(),
            "- [ ] Security review and fixes".to_string(),
            "- [ ] Documentation updates".to_string(),
            "- [ ] Production deployment and monitoring".to_string(),
            "".to_string(),
            "# CONTENT QUALITY GUIDELINES".to_string(),
            "".to_string(),
            "## Writing Style:".to_string(),
            "- Use present tense and active voice".to_string(),
            "- Be specific and measurable".to_string(),
            "- Include concrete examples".to_string(),
            "- Write for both humans and LLMs".to_string(),
            "".to_string(),
            "## Technical Depth:".to_string(),
            "- Include version numbers for dependencies".to_string(),
            "- Reference specific files, functions, or endpoints".to_string(),
            "- Provide code examples for complex concepts".to_string(),
            "- Link to external documentation where relevant".to_string(),
            "".to_string(),
            "## Structure Requirements:".to_string(),
            "- Use consistent header hierarchy".to_string(),
            "- Group related content under clear sections".to_string(),
            "- Include both high-level overview and specific details".to_string(),
            "- End with actionable next steps or success criteria".to_string(),
        ],
        workflow_guide: vec![
            "ALWAYS use proper markdown formatting for structure and readability".to_string(),
            "Length requirements: Vision ≥200 chars, Tech-stack ≥150 chars, Summary ≥100 chars, Specs ≥200 chars".to_string(),
            "Use ## headers for major sections, ### for subsections in all content types".to_string(),
            "Include code blocks with language specifications for technical examples".to_string(),
            "Use bullet points for features/requirements, numbered lists for sequential steps".to_string(),
            "Task lists must use - [ ] format for checkboxes to enable progress tracking".to_string(),
            "Include specific examples, version numbers, and concrete implementation details".to_string(),
            "Write in present tense with active voice for clarity and consistency".to_string(),
            "Reference external documentation with proper links where applicable".to_string(),
            "Use 'foundry validate_content' to verify formatting and content quality".to_string(),
        ],
    }
}

fn create_project_structure_help() -> HelpContent {
    HelpContent {
        title: "Foundry Project Structure".to_string(),
        description: "Understanding the file organization and directory structure that Foundry creates and manages.".to_string(),
        examples: vec![
            "~/.foundry/PROJECT_NAME/".to_string(),
            "├── vision.md      # High-level product vision and roadmap".to_string(),
            "├── tech-stack.md  # Technology choices and architecture decisions".to_string(),
            "├── summary.md     # Concise summary for quick context loading".to_string(),
            "└── specs/".to_string(),
            "    ├── 20250823_143052_user_auth/".to_string(),
            "    │   ├── spec.md        # Feature specification and requirements".to_string(),
            "    │   ├── task-list.md   # Implementation checklist (updated by agents)".to_string(),
            "    │   └── notes.md       # Additional context and design decisions".to_string(),
            "    └── 20250824_091234_api_endpoints/".to_string(),
            "        ├── spec.md".to_string(),
            "        ├── task-list.md".to_string(),
            "        └── notes.md".to_string(),
        ],
        workflow_guide: vec![
            "All files use markdown format for consistent rendering across tools".to_string(),
            "Spec directories use ISO timestamp format: YYYYMMDD_HHMMSS_feature_name".to_string(),
            "Feature names must use snake_case (e.g., user_auth, api_endpoints)".to_string(),
            "Project files provide context for LLM sessions".to_string(),
            "Spec files contain feature-specific implementation guidance".to_string(),
            "Task-list.md serves as living checklist - update as work progresses".to_string(),
            "Notes.md captures design decisions and context for future reference".to_string(),
        ],
    }
}

fn create_parameter_guidance_help() -> HelpContent {
    HelpContent {
        title: "Parameter Guidelines and Schemas".to_string(),
        description: "Detailed guidance on parameter requirements, formats, and validation rules for all Foundry commands.".to_string(),
        examples: vec![
            "# create_project parameters:".to_string(),
            "--vision: High-level product vision (≥200 chars, 2-4 paragraphs)".to_string(),
            "--tech-stack: Technology decisions with rationale (≥150 chars)".to_string(),
            "--summary: Concise vision+tech summary (≥100 chars)".to_string(),
            "".to_string(),
            "# create_spec parameters:".to_string(),
            "feature_name: snake_case identifier (e.g., user_auth)".to_string(),
            "--spec: Detailed requirements and implementation approach".to_string(),
            "--notes: Design decisions, dependencies, considerations".to_string(),
            "--tasks: Implementation checklist in markdown list format".to_string(),
            "".to_string(),
            "# validate_content parameters:".to_string(),
            "content_type: vision|tech-stack|summary|spec|notes".to_string(),
            "--content: Content to validate against type-specific rules".to_string(),
            "".to_string(),
            "# Common validation rules:".to_string(),
            "- Project names: kebab-case (my-awesome-project)".to_string(),
            "- Feature names: snake_case (user_authentication)".to_string(),
            "- Content: Non-empty, minimum length requirements".to_string(),
            "- Markdown: Valid markdown formatting encouraged".to_string(),
        ],
        workflow_guide: vec![
            "All content parameters are REQUIRED - Foundry never generates content".to_string(),
            "Use specific, descriptive project and feature names".to_string(),
            "Validate content before creation to catch issues early".to_string(),
            "Minimum content lengths ensure sufficient detail for LLM context".to_string(),
            "Rich parameter descriptions guide LLM content creation".to_string(),
            "Error messages provide actionable guidance for parameter fixes".to_string(),
        ],
    }
}

fn create_decision_points_help() -> HelpContent {
    HelpContent {
        title: "Decision Points and Tool Selection".to_string(),
        description: "Guidance for choosing the right Foundry tools based on user intent and context. Emphasizes user-driven decisions over automated sequences.".to_string(),
        examples: vec![
            "# Decision: User wants to start a project".to_string(),
            "Questions to ask:".to_string(),
            "- Do they have existing code to analyze? → analyze_project".to_string(),
            "- Are they starting from scratch? → create_project".to_string(),
            "- Do they have vision/tech-stack content ready? → Wait for content".to_string(),
            "".to_string(),
            "# Decision: User mentions a feature or functionality".to_string(),
            "Questions to ask:".to_string(),
            "- Have they described the feature requirements? → create_spec".to_string(),
            "- Do they need to think through the requirements first? → Ask for details".to_string(),
            "- Is there an existing project for this feature? → Check with list_projects".to_string(),
            "".to_string(),
            "# Decision: User wants to continue work".to_string(),
            "Questions to ask:".to_string(),
            "- Do they know which project? → load_project PROJECT_NAME".to_string(),
            "- Do they want to see all projects? → list_projects".to_string(),
            "- Do they want to work on a specific feature? → load_spec".to_string(),
            "".to_string(),
            "# Decision: User's intent is unclear".to_string(),
            "Clarifying questions to ask:".to_string(),
            "- 'What would you like to work on?'".to_string(),
            "- 'Are you starting something new or continuing existing work?'".to_string(),
            "- 'Do you have a specific feature in mind?'".to_string(),
        ],
        workflow_guide: vec![
            "Never assume user intent - always ask clarifying questions".to_string(),
            "Provide options based on context, not directive commands".to_string(),
            "Wait for user to provide content before using creation tools".to_string(),
            "Use conditional language: 'If you want X, then Y tool helps'".to_string(),
            "Guide decision-making, don't make decisions for the user".to_string(),
            "Tool selection should always follow user intent, not prescribed workflows".to_string(),
        ],
    }
}

fn create_tool_capabilities_help() -> HelpContent {
    HelpContent {
        title: "Tool Capabilities and Appropriate Usage".to_string(),
        description: "Understanding when each Foundry tool is appropriate and what user input is required for effective usage.".to_string(),
        examples: vec![
            "# create_project - When appropriate:".to_string(),
            "- User wants to start a new project from scratch".to_string(),
            "- User has provided vision, tech-stack, and summary content".to_string(),
            "- User input required: Complete content for all three sections".to_string(),
            "- Don't use without: User-provided content for vision/tech-stack/summary".to_string(),
            "".to_string(),
            "# analyze_project - When appropriate:".to_string(),
            "- User wants to create project structure for existing codebase".to_string(),
            "- LLM has analyzed codebase using analysis tools".to_string(),
            "- User input required: LLM-generated analysis-based content".to_string(),
            "- Don't use without: Thorough codebase analysis first".to_string(),
            "".to_string(),
            "# create_spec - When appropriate:".to_string(),
            "- User has described a specific feature they want to implement".to_string(),
            "- User has provided requirements or functionality details".to_string(),
            "- User input required: Feature description, requirements, implementation approach".to_string(),
            "- Don't use without: User-provided feature requirements and details".to_string(),
            "".to_string(),
            "# load_project - When appropriate:".to_string(),
            "- User wants to continue work on an existing project".to_string(),
            "- User has specified which project they want to work with".to_string(),
            "- User input required: Project name".to_string(),
            "- Don't use without: Clear user intent to work on specific project".to_string(),
            "".to_string(),
            "# load_spec - When appropriate:".to_string(),
            "- User wants to work on a specific feature".to_string(),
            "- User has mentioned a particular spec or feature name".to_string(),
            "- User input required: Project name, optionally spec name".to_string(),
            "- Don't use without: User intent to work on specific feature".to_string(),
            "".to_string(),
            "# validate_content - When appropriate:".to_string(),
            "- User wants to check content quality before creating projects/specs".to_string(),
            "- LLM wants to verify content meets requirements".to_string(),
            "- User input required: Content to validate and content type".to_string(),
            "- Don't use without: Actual content to validate".to_string(),
        ],
        workflow_guide: vec![
            "Every tool requires specific user input - never proceed without it".to_string(),
            "Tool appropriateness depends on user intent, not prescribed sequences".to_string(),
            "Wait for user to express clear intent before suggesting tools".to_string(),
            "Ask clarifying questions when user intent doesn't match tool capabilities".to_string(),
            "Provide tool options based on what user wants to accomplish".to_string(),
            "Remember: tools support user goals, they don't drive the workflow".to_string(),
        ],
    }
}

fn create_context_patching_help() -> HelpContent {
    HelpContent {
        title: "Context-Based Patching for Targeted Updates".to_string(),
        description: "Comprehensive guide for using context-based patching to make precise, targeted updates to specification files without full file replacement. Context patching uses surrounding text to identify exact locations for changes, dramatically reducing token usage and improving precision.".to_string(),
        examples: vec![
            "# Basic Context Patch Structure:".to_string(),
            "foundry update_spec PROJECT_NAME SPEC_NAME --operation context_patch --context-patch '{".to_string(),
            "  \"file_type\": \"tasks|spec|notes\",".to_string(),
            "  \"operation\": \"insert|replace|delete\",".to_string(),
            "  \"before_context\": [\"line before target\", \"another before line\"],".to_string(),
            "  \"after_context\": [\"line after target\", \"another after line\"],".to_string(),
            "  \"content\": \"new content to insert/replace\",".to_string(),
            "  \"section_context\": \"## Header Name (optional)\"".to_string(),
            "}'".to_string(),
            "".to_string(),
            "# Example 1: Mark Task Complete".to_string(),
            "# Current content: - [ ] Implement user authentication".to_string(),
            "foundry update_spec my-project my-spec --operation context_patch --context-patch '{".to_string(),
            "  \"file_type\": \"tasks\",".to_string(),
            "  \"operation\": \"replace\",".to_string(),
            "  \"before_context\": [\"## Phase 1\"],".to_string(),
            "  \"after_context\": [\"- [ ] Add password hashing\"],".to_string(),
            "  \"content\": \"- [x] Implement user authentication\"".to_string(),
            "}'".to_string(),
            "".to_string(),
            "# Example 2: Insert New Requirement".to_string(),
            "foundry update_spec my-project my-spec --operation context_patch --context-patch '{".to_string(),
            "  \"file_type\": \"spec\",".to_string(),
            "  \"operation\": \"insert\",".to_string(),
            "  \"section_context\": \"## Requirements\",".to_string(),
            "  \"before_context\": [\"- Password hashing with bcrypt\"],".to_string(),
            "  \"after_context\": [\"- Session management\"],".to_string(),
            "  \"content\": \"- Two-factor authentication support\"".to_string(),
            "}'".to_string(),
            "".to_string(),
            "# Example 3: Delete Outdated Content".to_string(),
            "foundry update_spec my-project my-spec --operation context_patch --context-patch '{".to_string(),
            "  \"file_type\": \"notes\",".to_string(),
            "  \"operation\": \"delete\",".to_string(),
            "  \"before_context\": [\"## Outdated Approach\"],".to_string(),
            "  \"after_context\": [\"## Current Implementation\"],".to_string(),
            "  \"content\": \"\"".to_string(),
            "}'".to_string(),
            "".to_string(),
            "# Example 4: Complex Multi-line Context".to_string(),
            "foundry update_spec my-project my-spec --operation context_patch --context-patch '{".to_string(),
            "  \"file_type\": \"spec\",".to_string(),
            "  \"operation\": \"replace\",".to_string(),
            "  \"before_context\": [".to_string(),
            "    \"## Acceptance Criteria\",".to_string(),
            "    \"- [ ] User can register with email\",".to_string(),
            "    \"- [ ] Password validation works\"".to_string(),
            "  ],".to_string(),
            "  \"after_context\": [".to_string(),
            "    \"- [ ] Session timeout handled\",".to_string(),
            "    \"## Implementation\"".to_string(),
            "  ],".to_string(),
            "  \"content\": \"- [x] Password validation works\"".to_string(),
            "}'".to_string(),
        ],
        workflow_guide: vec![
            "ALWAYS load current content first: foundry load_spec PROJECT_NAME SPEC_NAME".to_string(),
            "Use 3-5 lines of context for reliable matching (more context = better accuracy)".to_string(),
            "Include section_context when target appears multiple times in different sections".to_string(),
            "For insert operations: before_context = line before insertion, after_context = line after insertion".to_string(),
            "For replace operations: before_context = lines before target, after_context = lines after target".to_string(),
            "For delete operations: before_context = lines before target, after_context = lines after target, content = \"\"".to_string(),
            "Context matching is fuzzy (80% similarity) - minor formatting differences are handled".to_string(),
            "If context match fails, try broader context or use section_context for disambiguation".to_string(),
            "Escape JSON properly: use \\\" for quotes, \\n for newlines in content strings".to_string(),
            "Context patching achieves 70-90% token reduction vs full file replacement".to_string(),
            "".to_string(),
            "# When to Use Each Operation Type:".to_string(),
            "".to_string(),
            "**Use context_patch when:**".to_string(),
            "- Making small targeted changes (mark task complete, add single item, fix typo)".to_string(),
            "- You know the exact surrounding context of the change".to_string(),
            "- Want to minimize token usage and improve precision".to_string(),
            "- Content has clear, unique surrounding text for reliable matching".to_string(),
            "".to_string(),
            "**Use replace when:**".to_string(),
            "- Completely rewriting large sections or entire files".to_string(),
            "- Making major structural changes to content".to_string(),
            "- Context is unclear or content appears in multiple locations".to_string(),
            "".to_string(),
            "**Use append when:**".to_string(),
            "- Adding new content to the end of existing files".to_string(),
            "- Building up specifications iteratively".to_string(),
            "- Want to preserve all existing content and add more".to_string(),
            "".to_string(),
            "# Troubleshooting Context Matching:".to_string(),
            "".to_string(),
            "**\"Context not found\" errors:**".to_string(),
            "- Load current content to verify context still exists".to_string(),
            "- Try broader context (fewer lines) or more specific context".to_string(),
            "- Check for typos in before_context and after_context".to_string(),
            "- Use section_context to limit search scope".to_string(),
            "".to_string(),
            "**\"Multiple matches\" errors:**".to_string(),
            "- Add section_context to disambiguate (e.g., \"## Requirements\")".to_string(),
            "- Use more specific before_context and after_context".to_string(),
            "- Include more lines of context to make match unique".to_string(),
            "".to_string(),
            "**\"Invalid JSON\" errors:**".to_string(),
            "- Escape quotes in content: \\\"quoted text\\\"".to_string(),
            "- Use proper JSON array syntax: [\"line1\", \"line2\"]".to_string(),
            "- Validate JSON structure before sending".to_string(),
            "- Check for trailing commas or missing quotes".to_string(),
        ],
    }
}
